[{"url":"1-variables_and_basic_types/","title":"Variables and basic types in Julia","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https youtu.be Jip2Ym5DsxQ\" image \"http img.youtube.com vi Jip2Ym5DsxQ 0.jpg\" section 1 order 1 title \"Variables and basic types in Julia\" layout \"layout.jlhtml\" youtube id \"Jip2Ym5DsxQ\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils begin using PlutoUI TableOfContents end md\" Variables and basic types in Julia\" md\" Variables\" md\"\"\"A variable is simply a name associated to any type of value. To declare a new variable, we use ` `, also named assignment operator \"\"\" a 1 a md\"Instead of repeating the value, we can then use the variable directly \" b a 2 md\"\"\"You can name your variables as you want, except for some few reserved words such as `true`, `false`, `if`, `else`, because they are part of the language itself. We will see what they mean later. You can find the list of reserved keywords here https docs.julialang.org en v1 base base Keywords . Julia also allow using Unicode characters , which is awesome See by yourself \"\"\" α 2 md\"α is written by typing `\\alpha` and then `ctrl enter`. `ctrl enter` is used for autocompletion. We can even use emojis \" 🌴 25.0 md\"And it is valid Julia code.\" α 🌴 md\"As a sidenote, it is a convention to name your variable using lower case, and to separate words by underscores if needed, e.g. \" savings 5500.0 bike price 5000.0 remaining money savings bike price md\"If I buy this bike, I'll have remaining money € or or whatever on my account.\" md\" Basic types\" md\" Listing basic types\" md\"\"\" Values are all defined by a type. For example `1` is called an integer. We can see the type of a variable using `typeof ` The most basic types are Integers, numbers with no fractional part \"\"\" cars 10 md\"And the actual name of the type is \" typeof cars md\"Note it is called an `Int64`, not just `Int`. This is because my machine has a 64 bit architecture. If you run on a 32 bits machine, you would get `Int32` by default. This is all technical details, but if you're interested you can find more information here https docs.julialang.org en v1 manual integers and floating point numbers \" md\" Floating point numbers, meaning numbers with a fractional part \" max speed 250.0 typeof max speed md\" Characters, just one character defined using `'...'` \" rank 'A' typeof rank md\"\"\" Strings, one or several characters defined using `\"...\"` \"\"\" brand \"Tesla\" typeof brand md\"\"\"NB A single character declared using `\"...\"` instead of `'...'` is still a String, not a character \"\"\" typeof \"T\" md\" Booleans, logical type, either `true` or `false` \" is awesome true typeof is awesome md\"NB `true` and `false` are written in lower case, and are reserved keywords, meaning you can cannot assign values to them.\" md\" Conversion\" md\"Some types can be converted one into another. To do so, you can use `convert `, or the name of the type to convert into as follows \" typeof cars convert Float64,cars md\"or \" Float64 cars md\"We can also transform it into a string using `string ` \" cars string string cars md\"...and back into an integer using `parse ` \" parse Int,cars string md\"Some types cannot be converted into another without loss of information. For example what if you convert a float like `2.2` into an integer? \" Int 2.2 md\"Julia returns an `InexactError` because there is a loss of information here the `.2` part . But what about `2.0` then?\" Int 2.0 md\"It works Why? Because there is no loss of information here. What you should do in the case of `2.2`? Cut out some information \" rounded round 2.2 md\"Now we can convert it into an integer safely \" Int rounded md\"There is also a shortcut for that \" round Int,2.2 md\"You can also use other functions such as `floor `, `ceil ` or `trunk `.\" md\" Promotion\" md\"\"\"Promotion is converting multiple values with different types into a single common type with the least loss of information. Not all types have a promotion rule, but Real numbers do \"\"\" promote 1.0,1 md\"Here `promote ` returned both arguments as floating point numbers.\" "},{"url":"10-functions/","title":"Functions","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https youtu.be xxxx\" image \"http img.youtube.com vi xxxx 0.jpg\" section 10 order 10 title \"Functions\" layout \"layout.jlhtml\" youtube id \"xxxx\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils begin using PlutoUI TableOfContents end md\"\"\" Functions in Julia \"\"\" md\"\"\" What is a function? A function is a block of code that performs a specific task. It takes some input, processes it, and returns some output. Functions are a fundamental building block of programming, and they’re used to organize code into reusable, modular pieces. \"\"\" md\"\"\" Why are functions important? Functions are important because they allow us to write code that is more readable, reusable, and maintainable. By breaking our code into smaller, self contained pieces, we can make it easier to understand and debug. We can also reuse the same function in multiple places, which saves us time and effort. A function is written like so ```julia function function name argument1, argument2 Set of statements – Block of code end ``` \"\"\" md\"\"\" Function example Let's say we want to invest 10000€ on an account providing a 10% annual interest rate. How much will we get after ten years? Well, the formula is rather simple FV PV 1 r ^n where FV is the future value, PV is the present value, r is the annual rate of return, and n is the number of years. warning Please note that this function is only an example and should not be considered as investment advice. Now we can define a function that will implement the formula for calculating the future value of our investment, as shown below \"\"\" function future value investment, rate, years investment 1 rate ^years end md\"\"\" And we can call the function using its name, and the corresponding values for the arguments between parenthesis \"\"\" future value 10000, 0.10, 10 md\"\"\" Functions are useful because they allow you to organize your code into reusable, modular pieces, making it easier to read, write, and maintain. You can also pass functions as arguments to other functions, or return them as values. But we'll see that in a moment. \"\"\" md\"\"\" Different forms of functions in Julia Long form Julia has several ways to define and write functions. The long form we saw above is the most common, using the `function` and `end` keywords. This form is good for writing complex or multi line functions. Just for reference, here is the definition again ```julia function future value investment, rate, years investment 1 rate ^years end ``` Short form Another way to write functions is the short form, using the ` ` sign and a single expression. This form is good for writing simple or one line functions. For example, you can write the `` function like this ```julia future value investment, rate, years investment 1 rate ^years ``` Anonymous functions A third way to write functions is using anonymous functions, which are functions without a name. You can create an anonymous function using either the ` ` syntax or the `function` syntax. For example, you can create an anonymous function that squares a number like this ```julia x x^2 using function x x^2 end using function ``` note The first syntax is usually preferred using ` ` When you have multiple arguments to the function, you can pass them as a tuple. To define our future value as an anonymous function, we would do this ```julia investment, rate, years investment 1 rate ^years ``` note Notice how anonymous functions syntax is close to the short form definition of a function. Remove the function name, and replace ` ` with ` `. Anonymous functions are helpful for passing them to other functions, such as map or filter, that take functions as arguments. They also are extensively used for manipulating `DataFrames`. For example, you can use an anonymous function to square each element of an array like this \"\"\" map x x^2, 1, 2, 3 md\"\"\" Or compute the future value of several investments like so \"\"\" map investment, rate, years investment 1 rate ^years, 1000.0, 5000.0 , 0.15, 0.10 , 10, 10 md\"\"\" Passing arguments to functions Arguments are the values that you pass to a function when you call it. They are used to provide data or information to the function. Julia has several ways to pass arguments to functions, depending on how you want to specify them or how the function expects them. Positional arguments The simplest way to pass arguments is by position, meaning that the order of the arguments matters. This is what we used with the `future value` function above. ```julia function future value investment, rate, years investment 1 rate ^years end ``` The first value provided to the function call will be given to the function's first argument `investment`. The second will be given to `rate`, and the third to `years`. This is why we can call the function as follows \"\"\" future value 10000, 0.10, 10 md\"\"\" So, if you swap the order of the arguments, you will get a different result. Keyword arguments kwargs Another way to pass arguments is by keyword, meaning that when we call the function, we use the argument name followed by an equal sign and the value `arg value` . This way, the order of the arguments does not matter, and we can also omit some arguments if they have default values. Keyword arguments are defined after a \"` `\" in the argument lists. For example, our previous function would be rewritten like this ```julia function future value investment, rate, years investment 1 rate ^years end ``` note Notice the ` ` after the first parenthesis. This way, all our arguments have to be named when calling the function ```julia future value investment 10000, rate 0.10, years 10 ``` We can also mix positional and keyword arguments in the same function. For example, if we want users to name the third argument, we would define the function like so ```julia function future value investment, rate years investment 1 rate ^years end ``` And now, users should call the function as ```julia future value 10000, 0.10, years 10 ``` note Notice that you can omit the semicolon when calling a function with keyword arguments. Default values We can also define default values for some arguments. For example, if the function is regularly used to compute the future value over 10 years, we could define a default value for `years` ```julia function future value investment, rate, years 10 investment 1 rate ^years end ``` This way, users can call the function providing values for only the two first arguments ```julia future value 10000, 0.10 ``` And Julia will use a value of `10` for `years`. A pretty nice usage of default values is when using them for `kwargs` ```julia function future value investment rate 0.15, years 10 investment 1 rate ^years end ``` Because now, users can change the value of `rate` and `years` independently of their position in the function argument list ```julia future value 10000, years 40 ``` \"\"\" md\"\"\" warning Arguments with default values must always be positioned after the arguments that have no default value in the function definition. For example, the following would return an error ```julia function power p 2, x return x^p end ``` \"\"\" md\"\"\" Do block syntax When a function takes a function as its first argument, we can call it with the `do` syntax. This is especially useful when the function we want to pass has several lines. Let's define a test function that takes a function as argument, and apply it over the second argument \"\"\" function apply f f, y f y end md\"\"\" Let's try it by passing the `sin` function with argument 2 \"\"\" apply f sin, 2 which is the same as sin 2 apply f x sin x , 2 md\"\"\" Now if we have a more complicated function, we can use the `dot` syntax like so \"\"\" apply f 2 do y The `y` here is the argument passed from the call 2 This is the code of the function x sin y 2 3 return x end md\"\"\" This is very useful when we need to write a longer function that we would use only once. \"\"\" md\"\"\" Return By default, Julia returns the last evaluated value of the function. Depending on the source, it can be considered a good practice to explicitly `return` the last value for a long form function definition. It is also possible to return a value earlier using the `return` statement, for example with an `if` statement \"\"\" function test max x,y if y x return x end y end test max 1,2 test max 3,2 md\"\"\" Advanced function topics In this section, we will cover some more advanced topics related to functions in Julia, such as varargs, argument scope, function composition, piping, and dot syntax. Varargs Varargs are a way to write functions that can take an arbitrary number of arguments. You can write a varargs function by using the … syntax after the last positional argument. For example, you can write a function that sums any number of numbers like this \"\"\" function sum all x... s 0 for a in x s a end return s end md\"\"\" This function has one varargs argument x, which is bound to a tuple of all the values passed to the function. You can iterate over this tuple using a for loop, and add each element to a variable s. You can call this function with any number of arguments like this \"\"\" sum all 1, 2, 3 sum all 1, 2, 3, 4, 5 md\"\"\" Varargs are useful for writing functions that can handle variable or unknown numbers of arguments, such as print or println. Function scope The scope of a variable or object is the region of code where the variable is visible and can be used. From the wikipedia article https en.wikipedia.org wiki Scope computer science The scope helps prevent name collisions by allowing the same name to refer to different objects – as long as the names have separate scopes ^1 . In Julia, arguments and variables are local to the function body, meaning they are not visible outside the function definition. So, for example, if we define `x` as a global variable \"\"\" x 1 md\"\"\" note `x` is a global variable because it is declared in the global scope, i.e. not in a function, a module... \"\"\" md\"\"\" And define a function that has `x` as an argument \"\"\" function f x local argument return x end md\"\"\" Both `x` are unrelated, the `x` in the function is another variable internally \"\"\" f 2 md\"\"\" Notice that `f 2 ` returns 2, not 1, meaning that the function `f` defines its own `x`. Argument scope The default value of a function argument can be computed from the value of another argument, e.g. \"\"\" function g x,y x 2 x, y end md\"\"\" In this function, the default value for `y` is twice that of `x`. Let's see if it works \"\"\" g 2 md\"\"\" That is nice and all, but what happens if we reverse the position? \"\"\" function h y x 2, x 5 x, y end h md\"\"\" ⚠️ Now that's a problem ⚠️ The `x` in `y x 2` comes from the global scope We can check that with the ` code lowered` macro that shows us the underlying code that is produced when calling `h` \"\"\" code lowered h md\"\"\" We see on the first line that x comes from `Main` `Main.var\"workspace 376\".x` , which is the global scope. \"\"\" md\"\"\" So keep in mind this sentence from the Julia documentation When optional and keyword argument default expressions are evaluated, only previous arguments are in scope. This means that we should use this feature very carefully \"\"\" md\"\"\" Function composition note This whole section is paraphrased from Julia's documentation Function composition is when you combine functions together and apply the resulting composition to arguments. You use the function composition operator ∘ to compose the functions, so f ∘ g args… is the same as f g args… . For example, you can compose the sqrt and functions like this \"\"\" sqrt ∘ 3, 4 what is does is sqrt 3 4 md\"\"\" This adds the numbers first, then finds the square root of the result. Function composition is useful for creating new functions from existing ones without having to write them explicitly. Piping is when you apply a function to the previous function’s output. You use the pipe operator | to pipe the functions together, so x | f | g is the same as g f x . For example, you can pipe the and sqrt functions like this \"\"\" 3 | x x 4 | sqrt md\"\"\" This takes the value of 3, pipe it pass it to the anonymous function that adds 4 to the input value, then pipe the resulting value to the square root function. Piping is useful for writing code in a clear and readable way, especially when using anonymous functions. Broadcasting Broadcasting is done via the dot syntax . . It applies a function elementwise to an array or a collection. For example, you can apply the sin function to each element of an array like this \"\"\" A 1.0, 2.0, 3.0 sin. A returns sin 1.0 , sin 2.0 , sin 3.0 md\"\"\" Dot syntax is useful for performing vectorized operations on arrays or collections without having to write loops or map calls. \"\"\" md\"\"\" Conclusion That’s it for this tutorial on functions in Julia We’ve learned what functions are, why they’re important, and how to use them. I hope you found this tutorial helpful and informative. Thanks for watching \"\"\" "},{"url":"2-arrays/","title":"Arrays in Julia","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https youtu.be VKjIRDBk6qo\" image \"http img.youtube.com vi VKjIRDBk6qo 0.jpg\" section 2 order 2 title \"Arrays in Julia\" layout \"layout.jlhtml\" youtube id \"VKjIRDBk6qo\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils begin using PlutoUI PlutoUI.TableOfContents end md\" Arrays\" md\" Definition\" md\"An array is an ordered collection of elements. The Wikipedia webpage https en.wikipedia.org wiki Array data type tells us that it relates to the mathematical concepts of vectors 1d array , matrices 2d arrays and tensors multi dimensional arrays .\" md\" Creating an array\" md\" Empty array\" md\"We can create an empty array using the following commands \" a md\"`a` is an empty array, and it is of type `Any` which means it can store any type of values. This is the most general declaration of an array here, because we don't assume the type of the elements that will be stored in the array. It is very practical, but adds some limitations in terms of performance.\" md\"The prefered way when we now the type of the elements we will store is to declare it as follows \" a2 Array Float64,1 md\"Now if we ask Julia what is the type of `a2` \" typeof a2 md\"It returns typeof a2 . We can also use directly `eltype ` to get the type of the elements in an `Array` \" eltype a2 md\"There is also a short hand to `Array Float64,1 ` \" a float Float64 md\"And it works with other types, e.g. \" a3 Int64 eltype a3 md\" With values\" md\"We can directly instantiate an `Array` by providing values \" 1, 2 md\"Or using the function directly \" Int64 1.0,2.0 md\"Julia tries to promote the values by default to specialise the `Array`, meaning making an `Array` of one specific type \" 1.0, 1 md\"Here Julia promoted the `Float64` and `Int64` given as inputs into `Float64`. But if it can't, it will make an `Array` with element type `Any` \" 1.0, 1, \"1\" md\"There is a short hand to make `Arrays` filled with zeros or ones of a certain type \" zeros Int64,5 zeros Float64,5 md\"Or using any sequence \" collect 1 10 md\" Multiple dimensions\" md\"\"\"We only made one dimensional arrays also called Vectors until here, but we can make arrays of any dimensions. Let's make an Array of increased dimension one dimension i.e. Vector \"\"\" zeros Int64, 5 md\" two dimensions i.e. Matrix \" zeros Int64,5,2 md\"\"\"Note that a matrix can be declared using ` ` too using a space to make a new column, and a new line or ` ` for a new row using a new line \"\"\" 1 2 3 4 5 6 md\" using ` ` \" 1 2 3 4 5 6 md\" three dimensions i.e. Tensor \" zeros Int64,5,2,2 md\"etc...\" md\" Working with arrays\" md\"Let's make a vector and a matrix first \" vec 1,3,5,7 mat 1 2 3 4 5 6 7 9 md\" Indexing\" md\"\"\"Indexing is made using ` `. For example we would type `vec index ` to get the value in `vec` stored at `index` \"\"\" vec 2 md\"Similarly, `mat index 1, index 2 ` will return the value in `mat` stored at `index 1` in the first dimension the rows and `index 2` in the second dimension the columns \" mat 3,2 md\"\"\"There are some usefull keywords to index. For example use ` ` to get all values in a dimension. All rows and first column only \"\"\" mat ,1 md\" All columns and first row only \" mat 1, md\"or to get a range of values \" mat 1 3, md\"or `end` to get the last value \" mat 1,end md\"We can also index using booleans \" values we want false,true,false,false vec values we want md\"This is a very convenient feature because it allows us to index with more complex approaches, e.g. \" vec vec . 3 md\"We will see those kind of operations in a different notebook.\" md\" Add or remove elements\" md\" At the end of the array \" md\"We can add elements to the end of an array using `push ` \" begin vectmp1 copy vec push vectmp1,10 vectmp1 end md\"\"\" note We would simply use `push vec,10 ` outside of a Pluto notebook e.g. in a Julia script . But Pluto doesn't like when we mutate a variable meaning changing its value at several different places in the notebook. So we apply a trick here, were we put the code in a `begin ... end` statement to make it a single statement, and apply `push ` on a copy of the vector here `vectmp1` . If it is too complicated, no worries, just consider this big blob of code just as if it was only written `push vec,10 `. \"\"\" md\"And remove the last element using `pop ` \" begin vectmp2 copy vec pop vectmp2 vectmp2 end md\"\"\" note Note the ` ` at the end of the name of the functions. Functions ending with a ` ` in Julia mutate their first argument, meaning they modify it \"in place\". Those functions generally have their non mutating counterpart without the ` ` that computes the result and return it, but don't modify the object given as the first argument. But we'll get into that in a further notebook. \"\"\" md\" At the beginning of the array \" md\"We can add or remove elements at the beginning of the array using `pushfirst ` and `popfirst ` \" begin vectmp3 copy vec pushfirst vectmp3,0 end begin vectmp4 copy vec popfirst vectmp4 vectmp4 end md\"\"\" note We are still applying the `begin .. end` trick here because we're inside of a Pluto notebook and it's the case of many following functions that only exist in a mutating form . Just use `pushfirst vec,0 ` and `popfirst vec ` outside of Pluto. \"\"\" md\" Anywhere in the array \" md\"We can add or remove elements anywhere in the array using `insert ` and `deleteat ` \" begin vectmp5 copy vec insert vectmp5,2,15 end begin vectmp6 copy vec deleteat vectmp6,2 end md\" Concatenate\" md\"We can concatenate several one dimensional arrays together using `append ` at the end and `prepend ` at the beginning \" vec2 30,31,32 begin vectmp7 copy vec append vectmp7,vec2 end begin vectmp8 copy vec prepend vectmp8,vec2 end md\"And you can still use `deleteat `, but now using a range \" begin vectmp9 copy vec deleteat vectmp9,1 3 end md\"For more complex arrays we can use `hcat` and `vcat` and it works with vectors too \" hcat vec,vec hcat mat, 10,11,12,13 vcat mat, 10 11 md\"We can also simply use ` ` to make a new array \" mat 10 11 mat 10,11,12,13 md\" Reshape\" md\"We can change the dimensions of an Array, or reshaping it using `reshape`. For example we can reshape vec to a 2x2 matrix \" reshape vec,2,2 md\"\"\" Or reshape `mat` into a vector \"\"\" reshape mat,8 md\"\"\" If we are not sure about the size of our matrix, we can also use ` ` \"\"\" reshape mat, md\" Further information\" md\"\"\" There are some basic functions such as `length` or `size` to get the length of an array, and the size for each dimension \"\"\" length mat size mat md\"\"\" We will see in another notebook that arrays are very powerfull, and that we can make more complex operations such as finding a value in an array using a function, sorting, or doing mathematical operations. If you want more information, you can visit the official documentation here https docs.julialang.org en v1 manual arrays \"\"\" "},{"url":"3-tuples/","title":"Tuples in Julia","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https youtu.be pYTw1LGbRm0\" image \"http img.youtube.com vi pYTw1LGbRm0 0.jpg\" section 3 order 3 title \"Tuples in Julia\" layout \"layout.jlhtml\" youtube id \"pYTw1LGbRm0\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils begin using PlutoUI TableOfContents end md\"\"\" Tuples \"\"\" md\"\"\" A Tuple is, like an Array, an ordered set of elements. But there are a few differences between them tuples are immutable, and they track the type of each element they hold. And this is exactly what makes tuples better for performance in some cases Immutability means that once a tuple is declared, we can't change its values. \"\"\" md\"\"\" Declaration \"\"\" md\"\"\" A tuple is declared using a set of parenthesis, and values separated by comas \"\"\" t 1,2.0,\"3\",'4' md\"\"\" We can also force the type of the elements using `Tuple` instead \"\"\" Tuple Float64, Float64 1,2.0 md\"\"\" But it only works if the types of the elements match the one given, or if there's a method for converting one from the other. To get the type of the values stored in a tuple, we can use `typeof` \"\"\" typeof t md\"\"\" Indexing Because the values are ordered in Tuples, we can index them like arrays \"\"\" t 1 t 2 end md\"\"\" Immutability \"\"\" md\"\"\" Tuples are immutable, so we cannot modify their values once declared \"\"\" t 2 3.0 md\"\"\" Immutability can be inconvenient for most usages, but it allows much faster computations. In short and badly explained, your computer knows that immutable structures are not allowed to change over time, so it can move it closer to where the computation happens. If you want more details about that, search for the \"heap\" and \"stack\" keywords on the internet. But you don't have to understand this at this point, just remember that Tuples make your code fast If you're really interested though, watch the video from Christopher Rackauckas on Youtube, it is very nice and complete starting at the point he is talking about it \"\"\" html\"\"\" iframe width \"560\" height \"315\" src \"https www.youtube.com embed M2i7sSRcSIw?start 713\" title \"YouTube video player\" frameborder \"0\" allow \"accelerometer autoplay clipboard write encrypted media gyroscope picture in picture\" allowfullscreen iframe \"\"\" md\"\"\" This video https www.youtube.com watch?v OdQSWuG78Sk from appskill is also very nice. It is a little bit less technical than the one presented by C. Rackauckas. Note that it is presented for Python, but it is the same for Julia. \"\"\" md\"\"\" note Tuples are very fast for small collections 32 , but slower for larger ones. Prefer using `StaticArrays.jl` https github.com JuliaArrays StaticArrays.jl for this purpose. \"\"\" md\"\"\" Named tuples \"\"\" md\"\"\" Named tuples associate a name to each value of a tuple. It is declared using a key and a value such as ` key1 value1, key2 value2 `. For example we can declare a named tuple as follows \"\"\" fruits apples 2, bananas 10, mangos 3 md\"\"\" To declare a named tuple with a single value, use a coma after the value with no following values, e.g. \"\"\" a 1, typeof a md\"\"\" Because if you don't, it would be considered just a value as it is \"\"\" a2 1 typeof a2 md\"\"\" We can also of course use functions inside the tuple declaration \"\"\" fruits sum fruits , md\"\"\" Named tuples have another advantage, we can get a value using its associated name or key \"\"\" fruits.bananas md\"\"\" To list all the keys, we simply use `keys ` \"\"\" keys fruits md\"\"\" And to get all the values, we can use `values ` \"\"\" values fruits md\"\"\" If you want to force the type of an element, use the ` NamedTuple` macro instead \"\"\" NamedTuple a Float64,b String 1,\"casava\" md\"\"\" Recursive Tuples \"\"\" md\"\"\" We can use tuples inside tuples as follows \"\"\" rec tuple fruits banana 2, peach 5 , vegetables zucchini 2, pumpkin 2 md\"\"\" Then we can still index recursively by chaining the dot syntax \"\"\" zucc rec tuple.vegetables.zucchini md\"\"\" Or by chaining indexing \"\"\" peach rec tuple 1 2 md\"\"\" Usefull functions \"\"\" md\"\"\" Length, to get the length of a tuple \"\"\" length fruits md\"\"\" Splatting i.e. providing values as if they were single arguments is done using `...` \"\"\" fruits...,5 md\"\"\" Check if a tuple is empty \"\"\" isempty a md\"\"\" References official documentation https docs.julialang.org en v1 manual types Tuple Types geeksforgeeks https www.geeksforgeeks.org tuples in julia tutorialspoint https www.tutorialspoint.com julia julia tuples.htm sodocumentation.net https sodocumentation.net julia lang topic 6675 tuples \"\"\" "},{"url":"4-dictionnaries/","title":"Dictionaries in Julia","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https www.youtube.com watch?v 3Anx7csWSkc\" image \"http img.youtube.com vi 3Anx7csWSkc 0.jpg\" section 4 order 4 title \"Dictionaries in Julia\" layout \"layout.jlhtml\" youtube id \"3Anx7csWSkc\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils begin using PlutoUI PlutoUI.TableOfContents end using OrderedCollections md\"\"\" Dictionaries \"\"\" md\"\"\" A dictionary is an unordered collection of key value pairs of elements. Declaration The best way to understand what it means is by looking at one \"\"\" dict Dict \"🍌\" 4, \"🍓\" 15 md\"\"\" As we can see a dictionary is declared using the `Dict` function, and then elements are declared using the `key value` pair syntax. The keys and values can be of any type, and their type can differ between one key or value and another although it is not recommanded for performance reasons . For example we can use symbols and strings for the keys, and integer and string for the values \"\"\" Dict 🍌 4, \"🍓\" \"this is not the season\", 12 12.0 md\"\"\" And here's an example with integers \"\"\" Dict 1234 4, 999 15 md\"\"\" Because it is used to retreive a value, each key in a dictionary must be unique. You couldn't retreive a value if it shared the same index as one another. Please note also that a dictionary is unordered, meaning we can't index into a dictionary by using the order we used to declare our `key value` pairs. \"\"\" md\"\"\" We can also declare a dictionary in two steps using the zip function first we declare our keys and values separately \"\"\" mykeys 🍌, 🍓 myvalues 4, 15 md\"\"\" And then we use the zip function to create a `key value` pair for each pair of element inside our dictionary \"\"\" Dict zip mykeys,myvalues md\"\"\" Empty dictionary \"\"\" md\"\"\" We can declare an empty dictionary using `Dict `, and even constrain the types of the keys and the values that will be added as follows \"\"\" constrained dict Dict String, Float64 constrained dict \"a\" 2 constrained dict \"a\" constrained dict \"b\" \"test\" md\"\"\" Indexing \"\"\" md\"\"\"Indexing a dictionary is made using ` ` along with the key of choice. For example we would type `dict key ` to get the value in `dict` stored in `key` \"\"\" dict \"🍓\" md\"\"\" Remember that dictionaries are not ordered, but we can still reproduce the behavior of an array just for fun using integers as keys \"\"\" array dict Dict 1 \"first value\", 2 \"second value\" array dict 2 md\"\"\" If we want to index a value that does not exist yet in the dictionary, it returns an error \"\"\" array dict 3 md\"\"\" We can check if a key exists using `haskey` \"\"\" haskey array dict,2 md\"\"\" And if we're not sure if a key exist and want to return a default value if not, there's `get` \"\"\" get array dict,1,\"default value\" The key exists, so it returns its value get array dict,3,\"default value\" The key does not exist, it returns the default one md\"\"\" If you want to get all values or all keys at once, use `keys` and `values` like for arrays \"\"\" keys dict values dict md\"\"\" note As we can see `keys` and `values` return a `KeySet` and a `ValueIterator` respectively. But we can use `collect` to get them as arrays. \"\"\" collect values dict md\"\"\" Filter \"\"\" md\"\"\" Filtering values is rather simple, just use the filer function 🙂. It works by providing a filtering function as the first argument \"\"\" filter x iseven x.second , dict md\"\"\" note `x iseven x.second ` is an anonymous function, we'll get into that in the future. What it does here is testing if the value of a `key value` pair is even or not, and returns `true` if so, and `false` if not. `filter` then filters out the values that are not even, i.e. the ones that return `false`. \"\"\" md\"\"\" Mutate \"\"\" md\"\"\" Dictionaries are easy to work with. We can add new elements using `push `, merge two dictionaries using `merge` and delete elements using either `pop ` or `delete `. Let's see an example using the dict we previously declared. Here's a reminder of which elements it holds \"\"\" dict md\"\"\" Add elements \"\"\" md\"\"\" Now let's add a new element \"\"\" begin dict tmp copy dict push dict tmp, \"🍒\" 30 end md\"\"\" note If we were outside of Pluto, we would simply use `push dict, \"🍒\" 30 `. Pluto is designed around reactivity, so it is generally bad practice to mutate a variable inside a Pluto notebook. We would normally prefer assigning the results to a new variable. I use a trick here to still be able to show you an example with a mutating function i.e. one that change the value of its input argument directly . The trick is to put the code in a `begin ... end` statement to make it as a single statement, and apply `push ` on a copy of `dict` here `dict tmp` so `dict` is never changed. If it is too complicated, no worries, just consider this big blob of code just as if it was only written `push dict, \"🍒\" 30 `. \"\"\" md\"\"\" Merge dictionaries \"\"\" md\"\"\" We can merge two dictionaries into a single one using `merge` \"\"\" dict2 Dict \"🍆\" 2, \"🍅\" 4 merge dict,dict2 md\"\"\" Delete elements \"\"\" md\"\"\" To delete an element from a dictionary, you can either use `pop ` \"\"\" begin dict tmp2 copy dict pop dict tmp2, \"🍌\" end md\"\"\" You can see it returns 4 here. That is because `pop ` returns the value of the element it just removed, and it is very useful sometimes We can check the newly created `dict tmp2` and see if there still is the banana element \"\"\" dict tmp2 md\"\"\" Nope, it was removed as expected. \"\"\" md\"\"\" If you prefer to get the remaining elements instead of the one removed, you can use `delete ` \"\"\" begin dict tmp3 copy dict delete dict tmp3, \"🍌\" end dict tmp3 md\"\"\" Ordered dictionaries \"\"\" md\"\"\" We saw earlier that dictionaries are unordered. But if you think unordered collections are too chaotic and you want to put an end to this madness, you can use ordered dictionaries from the `OrderedCollections.jl` package instead. So what is an ordered dictionary? The only difference with a standard dictionary is that elements are ordered, meaning we assign them a position in the dictionary, and they stick to it. And if you add an element, it is added as the last element, as things should be. Think of it like an array with names for each element. \"\"\" begin order dict OrderedDict dict tmp push order dict, \"🌲\" 1 end md\"\"\" note If you have an error on the code above, it is certainly because you didn't activate the project before opening the pluto notebook, so the `OrderedCollections` package is not available to you. There's two solutions to this issue 1 activate the environment before opening this notebook. To do so, enter the following command in Julia ` activate .`. Then instantiate the environment by entering ` instantiate`. This will work assuming you are working from the whole julia course https github.com VEZY julia course project. 2 Or add a new cell below with the following code `import Pkg Pkg.add \"OrderedCollections\" `. \"\"\" md\"\"\" Useful functions \"\"\" md\"\"\" Union of two dictionaries \"\"\" union dict2, dict tmp md\"\"\" Intersection of two dictionaries \"\"\" intersect dict, dict tmp md\"\"\" Difference between two dictionaries \"\"\" setdiff dict2, dict tmp md\"\"\" These functions are related to mathematical sets. https upload.wikimedia.org wikipedia commons 8 86 A union B.svg ^1 The inclusion exclusion principle is used to calculate the size of the union of sets the size of the union is the size of the two sets, minus the size of their intersection. ^1 See markdown link for source. \"\"\" "},{"url":"5-basic_operators/","title":"Basic operators","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https www.youtube.com watch?v k2aGzLvN4uA\" image \"http img.youtube.com vi k2aGzLvN4uA 0.jpg\" section 5 order 5 title \"Basic operators\" layout \"layout.jlhtml\" youtube id \"k2aGzLvN4uA\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils begin using PlutoUI TableOfContents end md\"\"\" Basic operators Operators are symbols used to perform for example a basic mathematical operation. Some are very easy and straighforward, some are a little bit more complicated. Let's start by the simple ones. Numeric operators They include , , and , and are simply used as with a calculator as follows \"\"\" 1 2 1 2 1 2 1 2 md\"\"\" There is also the equal sign to assign a value to a variable \"\"\" a 1 a md\"\"\" There's the integer division using ÷ `\\div` tab \"\"\" 1 ÷ 2 md\"\"\" To get the reminder of a division, we use the modulus, which is defined by the percent sign \"\"\" 1 % 2 md\"\"\" This is especially usefull if you want to know if the value of a variable is odd or even. To do so, you would use the remainder of the division by 2, which gives 0 for an even number, and 1 for an odd number \"\"\" a % 2 b 2 b % 2 md\"\"\" To raise a value to the power of a number, we can use the caret \"\"\" 2^4 md\"\"\" There are some short hands if you want to update the value of a variable \"\"\" let var 1 var 1 end let var 1 var 1 end let var 1 var 2 end let var 1 var 2 end md\"\"\" Comparison operators Some operators can be used to compare two values. They always return a boolean value either `true` or `false`. Greater than \"\"\" 2 1 md\"\"\" Greater or equal to \"\"\" 2 1 md\"\"\" The opposite \"\"\" 2 1 2 1 md\"\"\" Testing equality \"\"\" 2 1 md\"\"\" note Note that equality is done using ` `, which is not the same than ` `, used to assign a value to a variable. \"\"\" md\"\"\" To test inequality, we use ` ` \"\"\" 2 1 md\"\"\" Boolean operators There are also the logical tests using ` ` \"not\" , `&&` \"and\" and `||` \"or\" on boolean values `true` or `false` . Negation The ` ` operator negates the boolean value of the statement \"\"\" false true md\"\"\" So this \"\"\" 2 1 md\"\"\" Is equivalent to this \"\"\" 2 1 md\"\"\" Logical \"and\" The logical \"and\" `&&` returns `true` only if the right hand side and left hand side values of the operator are both `true` \"\"\" true && true true && false md\"\"\" Logical \"or\" \"\"\" md\"\"\" The logical \"or\" returns true if at least one is true \"\"\" true || false false || false md\"\"\" In reality you'll use variables instead of boolean values directly. For example you could say that `c` is equal to `true` in the case both `a` and `b` are bellow 3 \"\"\" c a 3 && b 3 md\"\"\" Conditional execution \"\"\" md\"\"\" The nice thing with Julia is that it tests the conditions incrementally because we know that if the first condition is `false` in a `&&` statement, the whole statement will be false, and if the first condition is `true` in a `||` statement, the whole statement will be `true`. We can use that as a tool to conditionally execute a line of code. \"\"\" a 1 && \"a is equal to 1 \" b 1 && \"b is equal to 1 \" b 1 || \"b is not equal to 1 \" md\"\"\" The concept of conditional execution is very important, and we will see it in more details in a coming video. \"\"\" md\"\"\" Vectorizing operators All operators we just saw are applied to one value at a time. But very often we want to apply an operator over a sequence of values stored in an Array for example. To do so, we can use the vectorized version of the operators by adding a dot right before it. This is called broadcasting. We will see more details about that in another video. \"\"\" a vec 1, 2, 3 md\"\"\" For example adding a single value to a vector of values using the ` ` sign will return an error \"\"\" a vec 2 md\"\"\" THe error is a `MethodError`, because there is no method implemented for the ` ` function with a vector of integer and an integer. Using the vectorized version will work perfectly \"\"\" a vec . 2 md\"\"\" note In practice, the vectorized version applies the ` ` function sequentially over the values of the `a vec` array, and then return the results back as an array. \"\"\" md\"\"\" There are other ways to do so, such as the for loops or array comprehension, but we will see that in another video. \"\"\" "},{"url":"6-string_operators/","title":"Strings in Julia","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https youtu.be yZwHgdAEx5Q\" image \"http img.youtube.com vi yZwHgdAEx5Q 0.jpg\" section 6 order 6 title \"Strings in Julia\" layout \"layout.jlhtml\" youtube id \"yZwHgdAEx5Q\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils using PlutoUI TableOfContents md\"\"\" String operators \"\"\" md\"\"\" This is a notebook about Strings in Julia. All information you'll find here is taken from the official julia documentation https docs.julialang.org en v1 manual strings . \"\"\" md\"\"\" Characters From the official Julia documentation Strings are finite sequences of characters. A character is defined using `'`, for example \"\"\" a 'a' md\"\"\" Julia manages Unicode characters so you can use fun characters such as \"\"\" α 'α' md\"\"\" Or even emojis \"\"\" smiley '😀' md\"\"\" Define a string A String is defined using `\"` \"\"\" my string \"This is a string.\" md\"\"\" Multilines string can be declared as \"\"\" my long string \"\"\"This is a longer string on several lines \"\"\" md\"\"\" Or eventually using `\\n` to separate new lines on a single line \"\"\" my string 2 \"This is a string \\nmultiline string on a single line.\" md\"\"\" The advantage of using `\\\"\\\"\\\"` is that you can use `\"` inside them \"\"\" my string 3 \"\"\"This is a string using \"quotes\" inside.\"\"\" md\"\"\" Another way to use special characters like `\"` in a string is to escape it. To escape a character you can use `\\` \"\"\" my string 3 2 \"This is a string using \\\"quotes\\\" inside.\" md\"\"\" Both are the same \"\"\" my string 3 my string 3 2 md\"\"\" Indexing The fun thing about strings is that it is just a sequence of characters, so we can index into it to get the characters. For example to get the first character of out string \"\"\" my string 3 1 md\"\"\" Or the last one \"\"\" my string 3 end md\"\"\" We can think of a String as a vector of characters, so functions like `length` work \"\"\" length my string 3 md\"\"\" We can also get a sub string from the string by indexing using a sequence \"\"\" first word my string 3 1 4 typeof first word md\"\"\" We can also get one character as a 1 character string \"\"\" first letter as string my string 3 1 1 typeof first letter as string md\"\"\" Interpolation \"\"\" md\"\"\" We can use values from variables when creating a string using ` ` \"\"\" x 1 y 2 \"x is equal to x and y is equal to y\" md\"\"\" ` ` is a function, so you can pass more using parenthesis \"\"\" \"x y x y \" md\"\"\" For that reason, if you need to use \\ in a string, you must escape it as seen before, using `\\` \"\"\" \"using \\ in a sentence, and also using it as a function x is equal to x\" md\"\"\" note The escape character `\\` is visible when printing in Pluto, but would not be visible in a print to the user. For example you see the sentence written in markdown above is using an escape character before ` ` and it just displays the dollar sign, not `\\`. \"\"\" md\"\"\" Concatenation \"\"\" md\"\"\" We can concatenate two strings using `string` \"\"\" string \"First string\", \", second string\" md\"\"\" Or using ` ` as a shortcut \"\"\" \"First string\" \", second string\" md\"\"\" You can also use join to concatenate a string or a vector of strings with another string, e.g. \"\"\" join \"First string\", \"second string\" , \", \" md\"\"\" The vector of strings is concatenated together using \", \" as a separator. \"\"\" md\"\"\" Comparison We can compare strings with the usual operators ` ` for equality comparison \"\"\" \"a string\" \"another string\" \"a string\" \"another string\" md\"\"\" ` `, ` `, ` ` and ` ` \"\"\" \"a\" \"z\" \"a\" \"b\" \"ab\" \"aa\" \"aab\" \"aaa\" md\"\"\" Search We can search if a character is in another one using different functions \"\"\" findfirst isequal 'o' , \"school\" findlast isequal 'o' , \"school\" findall isequal 'o' , \"school\" md\"\"\" We can use the same functions to know if a string is in another \"\"\" findfirst \"is\", \"School is good \" md\"\"\" Or test whether a string occurs in a another \"\"\" occursin \"cat\", \"Oggy is my cat.\" md\"\"\" Replace We can replace words in a string using `replace` \"\"\" replace \"Oggy is my cat.\", \"cat\" \"wonderfull cat\" md\"\"\" `replace` takes a string to modify as the first argument, and a Pair as the second argument. The Pair is formatted as follows `\"string to replace\" \"string that will replace the first one\"`. \"\"\" md\"\"\" We can also replace single characters if needed \"\"\" replace \"Oggy is my cat.\", 't' 'r' md\"\"\" Regular expressions Regular expressions are used to search patterns in strings with some rules. A rule can be something such as \"starting with\", \"ending with\", \"containing as the third character, followed by a blank space and then an integer\". A regular expression is declared itself as a string, preffixed with an `r` \"\"\" typeof r\"test\" md\"\"\" Regex means Reg ular ex pression. For example you could be interested knowing if a string starts with an O In this case you can use `^` \"\"\" occursin r\"^O\", \"Oggy is my cat.\" md\"\"\" Here the regular expression can be translated to \"Is my string starting with O\". If we want to know if it ends with something, we cans use as a suffix \"\"\" occursin r\"cat. \", \"Oggy is my cat.\" md\"\"\" Now here we made a mistake without realising it. How? Look at the following \"\"\" occursin r\"cat. \", \"Oggy is my cats\" md\"\"\" It returns `true` again, but our last character is a `.`, not an s This is because `.` is a special character in regular expression that is used to match any character. Here is a little list of the most important special characters `^` starts with used as a prefix, e.g. `r\"^a\"` means starts with \"a\" ` ` ends with used as a suffix, e.g. `r\"a \"` means ends with \"a\" ` ` appears 0 or more times e.g. `r\"a \"` has \"a\" zero or more times ` ` appears 1 or more times e.g. `r\"a \"` has \"a\" one or more times ` n ` appears n time e.g. `r\"a 2 \"` has \"a\" two times ` alpha ` alphabetic character ` alnum ` alphanumeric character ` blank ` space or tab ` x y ` range \"\"\" occursin r\"^b\", \"banana\" starts with \"b\" occursin r\"5 \", \"My home adress is 5\" ends with 5 occursin r\"c \", \"banana\" has \"c\" 0 or more times 0 times here occursin r\"c \", \"banana\" has \"c\" 1 or more times occursin r\"a 3 \", \"banana\" has \"a\" three times in a row not here occursin r\"a alpha c\", \"abc\" has \"a\", an alphabetical letter and then a \"c\" occursin r\"a alnum c\", \"abc\" has \"a\", an alphanumeric character and then \"c\" occursin r\"a blank \", \"a \" has \"a\" and then a blank occursin r\" 0 9 23\", \"123\" has a number between 0 and 9 and then 2 and 3 md\"\"\" Now imagine we manage a data base of animals and their id is a string of their names and an index \"\"\" string vec \"cat122\", \"bird233\", \"bird001\", \"dog001\", \"dog899\", \"error101\", \"101warning\" md\"\"\" If we want only the animals that have an id greater than 200, we can use a regular expression such as \"\"\" id greater than 200 r\"^ alpha 3,4 2 9 \" md\"\"\" Which means in plain english We want a string that starts `^` with three or four ` 3,4 ` alphabetical letters ` alpha ` and followed by a number between 2 and 9 ` 2 9 ` . We don't want any filter on the following characters. And our results is \"\"\" string vec occursin. id greater than 200, string vec md\"\"\" note What happens here is that we broadcast occursin the point after the function name `occursin.` because we apply the function on a vector. Then we use the output of occursin to index in our vector `string vec`, which only returns the strings that were selected by our regular expression. \"\"\" md\"\"\" Now we could make it more generic using this kind of regular expression instead \"\"\" generic regexp r\"^ alpha 2 9 0 9 2, \" md\"\"\" which would ask for a string starting `^` with any number ` ` of alphabetical letters ` alpha ` followed by an integer value greater that 2 ` 2 9 ` and at least two ` 2, ` number values between 0 and 9 at least 2 to get at least 200 . This way the expression would work for any kind of animal name and index in the database, not just the ones above \"\"\" occursin generic regexp, \"unicorn35599944455\" md\"\"\" Yes, there are more unicorns than humans, but I don't know where they live. \"\"\" "},{"url":"7-compound_expressions/","title":"Compound Expressions","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https youtu.be zCvYmbP1esc\" image \"http img.youtube.com vi zCvYmbP1esc 0.jpg\" section 7 order 7 title \"Compound Expressions\" layout \"layout.jlhtml\" youtube id \"zCvYmbP1esc\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils begin using PlutoUI TableOfContents end md\"\"\" Compound Expressions A compound expression is a sequence of statements. Begin...end If you followed through the previous videos of the tutorial, you already made acquaintance with one of them the `begin...end` statement. The `begin...end` statement is used when we want to execute several expressions as if they where executed as a single one. The `begin...end` always returns the last evaluated expression. Let's take an example \"\"\" x begin a 1 b 2 a b end md\"\"\" Here we put three lines of code inside the `begin...end` statement. We first define the value of `a`, then the value of `b`, and we evaluate their sum. The result of the sum is then returned by the whole expression and assigned to the variable `x`. All variables created inside the `begin...end` statement are available to the global scope. We can access the value of `a` \"\"\" a md\"\"\" And the value of `b` \"\"\" b md\"\"\" And of course the value of `x` too \"\"\" x md\"\"\" I know that your next question is probably that we could simply not use the `begin...end` statement at all. In this case yes, we could define it like so instead ```julia a 1 b 2 x a b ``` And this would be way more readable. But keep in mind that it is only a rather bad example for keeping it simple. You'll see examples where they are quite usefull in further videos. And actually Pluto notebooks are a good example for that, because if you need to put several lines of code inside a single cell, you are required to use a `begin...end` statement. \"\"\" md\"\"\" Let...end Another nice expression that we encountered previously is the `let...end` statement. This one is very similar to the `begin...end` statement, but has one more interesting property all variables created inside are local variables, meaning they are not exposed to the global scope. Let's take an example to better understand. Let's define an expression equivalent to the previous one using `let...end` \"\"\" y let c 1 d 2 c d end md\"\"\" Ok, seems to be same no? Yes, but the difference is that this time the `c` and `d` variables are not available to us. \"\"\" c md\"\"\" To avoid the error we can test if a variable exist in the global scope using the ` isdefined` macro \"\"\" isdefined c isdefined d md\"\"\" Another usefull thing of `let...end` is that we can assign the values of outside variables with the same name inside the `let...end` statement, and the variable inside would be a totally different variable \"\"\" z 1 res let z z z z 1 end md\"\"\" What is the value of res know? Well we see it right above, it is 2. Because it is the result of the last evaluated expression inside the `let...end` statement. But what is the value of `z` now? If you followed, the value of `z` didn't change, because we changed the value of a totally different `z`, the one inside the `let...end` statement that creates a new scope \"\"\" z "},{"url":"8-conditional_statements/","title":"Conditional Statements","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https youtu.be qNK9C3ewoGE\" image \"http img.youtube.com vi qNK9C3ewoGE 0.jpg\" section 8 order 8 title \"Conditional Statements\" layout \"layout.jlhtml\" youtube id \"qNK9C3ewoGE\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils This Pluto notebook uses bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of bind gives bound variables a default value instead of an error . macro bind def, element quote local iv try Base.loaded modules Base.PkgId Base.UUID \"6e696c72 6542 2067 7265 42206c756150\" , \"AbstractPlutoDingetjes\" .Bonds.initial value catch b missing end local el esc element global esc def Core.applicable Base.get, el ? Base.get el iv el el end end begin using Dates using PlutoUI end md\"\"\" Control flow conditional statements Like any other programming language, Julia provides expressions for controlling the execution flow of a program. This notebook is based on the Julia documentation https docs.julialang.org en v1 manual control flow . If else The `if` statement helps us execute some code only if a condition evaluates to `true`. It is written with the form ```julia if condition ... end ``` with ` ... ` being any number of lines of Julia code. But let's take an example to better understand. Say we go the gym every wednesday, and that we want Julia to remind us when it is time to go. Let's simulate the day with a variable called `today` that numbers days from 1 to 7. We can change the values using the following slider \"\"\" bind today PlutoUI.Slider 1 7 show value true if today Wednesday \"🏃Move Move Move 🐸 It's Wednesday 🐸 Gym day 🏃\" end md\"\"\" See what happens when we move the slider to the third day? The condition `today Wednesday` evaluates to `true` so the code inside the if...end expression is evaluated. But we can make it even better by outputing a value when it is not wednesday. We could add an `if` statement below and test if the day is not wednesday, but an even shorter way to do it is by using the `else` statement as follows \"\"\" if today Wednesday \"🏃Move Move Move 🐸 It's Wednesday 🐸 Gym day 🏃\" else \"😴Chill out it is not Wednesday yet😴\" end md\"\"\" The `else` statement helps us execute another chunk of code if the condition is `false`. But what if we want to go to the gym on the Mondays too? Well we can use the `elseif` statement like follows \"\"\" if today Monday \"🏃Move Move Move It's Monday Gym day 🏃\" elseif today Wednesday \"🏃Move Move Move 🐸 It's Wednesday 🐸 Gym day 🏃\" else \"😴Chill out it is not Monday or Wednesday😴\" end md\"\"\" And the nice thing is that we can chain them as we want \"\"\" if today Monday \"🏃Move Move Move It's Monday Gym day 🏃\" elseif today Wednesday \"🏃Move Move Move 🐸 It's Wednesday 🐸 Gym day 🏃\" elseif today Friday \"🏃Move Move Move It's Friday Gym day 🏃\" else \"😴Chill out it is not Gym day yet😴\" end md\"\"\" note In general it is considered best practice avoiding code repetition, so a better approach would be ```julia if today in Monday, Wednesday, Friday \"🏃Move Move Move It's Dates.dayname today Gym day 🏃\" else \"😴Chill out it is not Gym day yet😴\" end ``` \"\"\" if today in Monday, Wednesday, Friday \"🏃Move Move Move It's Dates.dayname today Gym day 🏃\" else \"😴Chill out it is not Gym day yet😴\" end md\"\"\" If else shortcuts Sometimes we want to execute something conditionnaly but more shortly than using `if...else...end`. There're two ways of doing that ```julia condition ? code if true code if false ``` We can read this as is the condition true ? , if yes execute what follows, else execute the other one. Here is an example \"\"\" today Wednesday ? \"🐸 It's Wednesday 🐸 \" \"It's not wednesday\" md\"\"\" The expression `today Wednesday` is first evaluated, if it is `true` the whole expression returns `\"It's Wednesday \"`, else it returns `\"It's not wednesday\"`. \"\"\" md\"\"\" But what if we don't need the `else` statement? Well there is another shorcut for that one the `&&` or `||`. The `&&` statement doesn't evaluate the right hand side of its expression if the left hand side is `false`, and the `||` only evaluates its right hand side if the left hand side is `false` ```julia condition && code if true ``` The statement can be read as If condition is `true`, execute ` code if true `, else do nothing. ```julia condition || code if false ``` The statement can be read as If condition is `false`, execute ` code if false `, else do nothing. Here are some examples \"\"\" today Wednesday && \"It's Wednesday \" md\"\"\" The expression `\"today Wednesday\"` is evaluated, if it is `true` the `\"It's Wednesday \"` expression is evaluted, and if it is `false`, it doesn't evaluate it and continue to the next line of code. \"\"\" today Wednesday || \"It's not Wednesday yet.\" begin TableOfContents end "},{"url":"9-for_loops/","title":"For loops","tags":["lecture","course"],"text":" A Pluto.jl notebook v0.19.27 frontmatter chapter 1 video \"https youtu.be wTiVtP5tYPY\" image \"http img.youtube.com vi wTiVtP5tYPY 0.jpg\" section 9 order 9 title \"For loops\" layout \"layout.jlhtml\" youtube id \"wTiVtP5tYPY\" description \"\" tags \"lecture\", \"course\" using Markdown using InteractiveUtils using PlutoUI md\"\"\" Control flow loops For loops For loops help us execute code several times over. They are written like so ```julia for i in range ... end ``` The `for` loop can be read as for each `i` value in `range`, execute the code in ` ... ` The `range` expression can be any iterable object. It usually is a range, vector, tuple or string. Let's start with a simple range example \"\"\" for i in 1 3 println i end md\"\"\" As stated before, we can use any iterable in the for loop a range \"\"\" for i in 1 3 println i end md\"\"\" A vector \"\"\" for i in 3,4,5 println i end md\"\"\" a tuple \"\"\" for i in 7,4,1 println i end md\"\"\" a NamedTuple \"\"\" for i in a 7, b 4, c 1 println i end md\"\"\" or a Dict \"\"\" for i in Dict a 7, b 4, c 1 println i end md\"\"\" A nice synthax with dicts is that we can also use the keys and the values inside the loop as two different variables \"\"\" for key,value in Dict a 1, b 2, c 3 println \"key \", key, \", value \", value end md\"\"\" Interesting, but not very useful. Loops are generally used to compute a value based on the range. It can be for example summing the values of a vector \"\"\" begin x 0 rand vec rand Float64, 10 for i in eachindex rand vec println i global x rand vec i end x end md\"\"\" In this case we used `eachindex` to iterate over `rand vec`. This loop mean iterate over each value in `rand vec`, and add each of these value `rand vec i ` to the global variable `x`. The output is then the sum of all values in `rand vec`. We'll see below why we need a `global` variable here. \"\"\" md\"\"\" Helpers \"\"\" md\"\"\" `eachindex` automatically iterate over all elements of an object \"\"\" for i in eachindex 2, 3, 5 println i end md\"\"\" `enumerate` like `eachindex` iterate over all elements of an object, but gives the index and value of the iteration as a tuple \"\"\" for i in enumerate 2, 3, 5 println i end for index,value in enumerate 2, 3, 5 println \"index \", index,\", value \", value end md\"\"\" `continue` goes to the next iteration without executing the code below \"\"\" for i in 1 5 i 3 && continue execute this line only if i 3 println i end md\"\"\" `break` break the loop, i.e stop the iterations \"\"\" for i in 1 5 i 4 && break stop the iterations if i 4 println i end md\"\"\" Using two iterators Sometimes we need to iterate over two iterators, for example if we need to iterate over the columns and rows of a matrix \"\"\" let mat zeros 3,3 for col in 1 3 for row in 1 3 mat row,col row col end end mat end md\"\"\" Well this notation can be compacted to be on the same line of code such as \"\"\" let mat zeros 3,3 for col in 1 3, row in 1 3 mat row,col row col end mat end md\"\"\" note Notice that we iterate on the rows of the matrix in the inner for loop, and on the column in the outer loop. This is because Julia stores the information in a column major way, meaning two contiguous elements of the same column will also be contiguous in memory. Iterating over rows before columns ensures that we iterate over elements that are next to each other on the memory, which is faster. \"\"\" md\"\"\" Array comprehension In Julia, we can create objects directly from a loop, this is called array comprehension when creating an array. For example if we want to create an array filled with three random values, we would do \"\"\" i for i in rand Int, 3 md\"\"\" It also works for other types of objects such as `Dict` \"\"\" Dict key value for key in 🍎, 🍍, 🍑 , value in 10, 3, 20 md\"\"\" Scope \"\"\" md\"\"\" warning This section is presented here for completeness only. The concept of variable scope will be introduced in a further tutorial. It is completely ok if you don't understand what is written below just yet. \"\"\" md\"\"\" There are two things to keep in mind when using a `for` loop The `for` loop introduces a local scope, it means that any variable created inside the loop is not available outside. The for loop cannot update a global variable if it already exist because it would be ambiguous. So either we explicitely declare it `local` to create a new local variable or `global` to update the global variable. \"\"\" md\"\"\" Here is a failed attempt of updating a global variable `a` from within the `for` loop without telling Julia what to do \"\"\" begin a 0 for i in 1 3 b 1 i a b end a, isdefined b end md\"\"\" note It will work if you copy paste the code in the REPL because it behaves a little bit differently to ease the interactive development, for example it helps developers to copy paste code from within a function and will work as in the function. \"\"\" md\"\"\" Here it is obvious that our intent was to update the value of the global variable `a`. To do so, we have to say it explicitely inside the loop using the `global` keyword \"\"\" begin a2 0 for i in 1 3 b 1 i global a2 b end a2, isdefined b end md\"\"\" Another simpler solution is to put the code inside a function \"\"\" begin function test a 0 for i in 1 3 b 1 i a b end a, isdefined b end test end md\"\"\" This time it will work because the function introduces a local scope, so `a` already exists as a local variable, no need to tell Julia the for loop updates `a` from before, it is already obvious. \"\"\" begin TableOfContents end "},{"url":".","title":"index","tags":["homepage"],"text":""},{"url":"installation/","title":"Software installation","tags":["welcome"],"text":"First-time setup: Install Julia & Pluto You can watch the video below made By Fons van der Plas for the  Computational Thinking  course at MIT. It explains how to install Julia and Pluto on your computer. In fact, this whole page comes from the  course here . Text and pictures version: Step 1: Install Julia  1.8.2 Go to  https://julialang.org/downloads  and download the current stable release, Julia  1.8.2 , using the correct version for your operating system (Linux x86, Mac, Windows, etc). Step 2: Run Julia After installing,  make sure that you can run Julia . On some systems, this means searching for the “Julia  1.8.2 ” program installed on your computer; in others, it means running the command  julia  in a terminal. Make sure that you can execute  1 + 1 : Make sure that you are able to launch Julia and calculate  1+1  before proceeding! Step 3: Install  Pluto Next we will install the  Pluto , the notebook environment that we will be using during the course. Pluto is a Julia  programming environment  designed for interactivity and quick experiments. Open the  Julia REPL . This is the command-line interface to Julia, similar to the previous screenshot. Here you type  Julia commands , and when you press ENTER, it runs, and you see the result. To install Pluto, we want to run a  package manager command . To switch from  Julia  mode to  Pkg  mode, type  ]  (closing square bracket) at the  julia>  prompt: \njulia> ]\n\n(@v 1.8 ) pkg>\n The line turns blue and the prompt changes to  pkg> , telling you that you are now in  package manager mode . This mode allows you to do operations on  packages  (also called libraries). To install Pluto, run the following (case sensitive) command to  add  (install) the package to your system by downloading it from the internet.\nYou should only need to do this  once  for each installation of Julia: \n(@v 1.8 ) pkg> add Pluto\n This might take a couple of minutes, so you can go get yourself a cup of tea! You can now close the terminal. Step 4: Use a modern browser: Mozilla Firefox or Google Chrome We need a modern browser to view Pluto notebooks with. Firefox and Chrome work best. Second time:  Running Pluto & opening a notebook Repeat the following steps whenever you want to work on a project or homework assignment. Step 1: Start Pluto Start the Julia REPL, like you did during the setup. In the REPL, type: julia> using Pluto\n\njulia> Pluto.run()\n The terminal tells us to go to  http://localhost:1234/  (or a similar URL). Let’s open Firefox or Chrome and type that into the address bar. If you’re curious about what a  Pluto notebook  looks like, have a look at the  Featured Notebooks . These notebooks are useful for learning some basics of Julia programming. If you want to hear the story behind Pluto, have a look a the  JuliaCon presentation . If nothing happens in the browser the first time, close Julia and try again. And please let us know! Step 2a: Opening a notebook from the web This is the main menu - here you can create new notebooks, or open existing ones. Our homework assignments will always be based on a  template notebook , available in this GitHub repository. To start from a template notebook on the web, you can  paste the URL into the blue box  and press ENTER. For example, homework 0 is available  here . Go to this page, and on the top right, click on the button that says “Edit or run this notebook”. From these instructions, copy the notebook link, and paste it into the box. Press ENTER, and select OK in the confirmation box. The first thing we will want to do is to save the notebook somewhere on our own computer; see below. Step 2b: Opening an existing notebook file When you launch Pluto for the second time, your recent notebooks will appear in the main menu. You can click on them to continue where you left off. If you want to run a local notebook file that you have not opened before, then you need to enter its  full path  into the blue box in the main menu. More on finding full paths in step 3. Step 3: Saving a notebook We first need a folder to save our homework in. Open your file explorer and create one. Next, we need to know the  absolute path  of that folder. Here’s how you do that in  Windows ,  MacOS  and  Ubuntu . For example, you might have: C:\\Users\\fons\\Documents\\18S191_assignments\\  on Windows /Users/fons/Documents/18S191_assignments/  on MacOS /home/fons/Documents/18S191_assignments/  on Ubuntu Now that we know the absolute path, go back to your Pluto notebook, and at the top of the page, click on  “Save notebook…” . This is where you type the  new path+filename for your notebook : Click  Choose . Step 4: Sharing a notebook After working on your notebook (your code is autosaved when you run it), you will find your notebook file in the folder we created in step 3. This the file that you can share with others, or submit as your homework assignment to Canvas. \nconst run = f => f();\nrun(async () => {\nconst versions = await (await fetch(`https://julialang-s3.julialang.org/bin/versions.json`)).json()\nconst version_names = Object.keys(versions).sort().reverse()\nconst stable = version_names.find(v => versions[v].stable)\nconsole.log({stable})\nconst pkg_stable = /\\d+\\.\\d+/.exec(stable)[0]\ndocument.querySelectorAll(\"auto-julia-version\").forEach(el => {\n    console.log(el)\n    el.innerText = el.getAttribute(\"short\") == null ? stable : pkg_stable\n})\n});"},{"url":"search/","title":"Search results","tags":[],"text":"window.init_search(); Search Results \nLoading..."},{"url":"sidebar data/","title":"sidebar data","tags":[],"text":"Dict main \"welcome\" collections \"welcome\" .pages, \"Course\" collections \"course\" .pages, \"Module 2 Social Science & Data Science\" collections \"module2\" .pages, \"Module 3 Climate Science\" collections \"module3\" .pages, , about Dict authors name \"Rémi Vezy\", url \"https www.remivezy.com\" , , title \"Julia course\", subtitle \"From Total Beginner To Power User\", term \"\", institution \"\", institution url \"\", institution logo \"julia logo color.svg\", institution logo darkmode \"julia logo dark.svg\" "}]